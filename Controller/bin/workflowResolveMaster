#!/usr/bin/perl

use strict;
use XML::Simple;
use lib "$ENV{GUS_HOME}/lib/perl";
use ReFlow::Controller::ResolveTemplate;
use Data::Dumper;

usage() unless scalar(@ARGV) == 2;

my ($masterXmlFile, $libDir) = @ARGV;

# use xml parser to find each <templateInstance> in master, and its attributes
my $templateInstances = parseMasterFile($masterXmlFile);

# now scan the master file and substitute resolved template text
# for each <templateInstance> and also resolve each <templateDepends>
open(MASTER, $masterXmlFile) || die "Error: can't open master xml file '$masterXmlFile'\n";

my $instanceIndex;
my $foundInstanceStart;
my $foundInstanceEnd;
my @output;
my $templatesUsed = {};
while(<MASTER>) {
  if (/\<templateInstance/) {
    $foundInstanceStart = 1;
    $foundInstanceEnd = /\/\>/;
  } elsif ($foundInstanceStart &&  /\/\>/) {
    $foundInstanceEnd = 1;
  } elsif (/\<templateDepends/) {
    my @resolvedDepends = processTemplateDepends($_, $templatesUsed);
    push(@output, @resolvedDepends);
  } else {
    push(@output, $_);  # just a regular line
  }

  # have found the end of a <templateInstance>
  if ($foundInstanceEnd) {
    $foundInstanceStart = $foundInstanceEnd = 0;
    my $resolvedTemplate =
      processTemplateInstance($templateInstances, $templatesUsed, $instanceIndex++, $libDir);
    push(@output, $resolvedTemplate);
  }
}
print join("", @output);


##################################################################

# parse master xml file.  use the result to grab attributes of each
# <templateInstance> element.  (ignore the rest).
sub parseMasterFile {
  my ($masterXmlFile) = @_;
  my $xml = new XML::Simple();
#  my $xmlData = $xml->XMLin($masterXmlFile, SuppressEmpty => undef, ForceArray=>['templateInstance']);
  my $xmlData = eval{ $xml->XMLin($masterXmlFile, SuppressEmpty => undef, ForceArray=>['templateInstance'], KeyAttr=>[]) };
  die "$@\nerror processing XML file $masterXmlFile\n" if($@);
#    print STDERR Dumper $xmlData;

  return $xmlData->{templateInstance};
}


sub processTemplateInstance {
  my ($templateInstances, $templatesUsed2, $instanceIndex, $libDir) = @_;

  my $instance = $templateInstances->[$instanceIndex-1];

  my $xmlFile = $instance->{xmlFile};
  my $name = $instance->{name};
  my $rtcFile = $instance->{rtcFile};

  # resolve the template (substitute in macro values, etc)
  my ($resolvedTemplateString, $stepNames) =
    ReFlow::Controller::ResolveTemplate::resolve("$libDir/xml/workflowTemplates/$xmlFile",
						 "$libDir/rtc/$rtcFile", $name);

  # remember that we have seen this template (and the steps it contains)
  # and remember the name we called it with.
  if (!$templatesUsed2->{$xmlFile}) {
    $templatesUsed2->{$xmlFile}->{instanceNames} = [$name];
    $templatesUsed2->{$xmlFile}->{stepNames} = $stepNames;
  } else {
    push(@{$templatesUsed2->{$xmlFile}->{names}}, $name);
  }

  return
"  <!-- START templateInstance name=\"$name\" xmlFile=\"$xmlFile\" rtcFile=\"$rtcFile\" -->
$resolvedTemplateString
  <!-- END -->
";
}


sub processTemplateDepends {
  my ($line, $templatesUsed) = @_;

  my @resolvedDepends;

  if ($line =~ /\<templateDepends name\s*\=\s*\"(.+?)\" xmlFile\s*\=\s*\"(.+?)\"/) {
    my $dependsName = $1;
    my $templateFile = $2;
    if ($templatesUsed->{$templateFile}) {
      my $templateStepNames = $templatesUsed->{$templateFile}->{stepNames};
      if (!grep(/^$dependsName$/, @$templateStepNames)) {
	die "Error: can't find step with name '$dependsName' in template file '$templateFile' (used in <templateDepends> on line $.)\n";
      }
      foreach my $name (@{$templatesUsed->{$templateFile}->{instanceNames}}) {
	push(@resolvedDepends, "      <depends name=\"$name$dependsName\"/>\n");
      }
    } else {
      die "Error: <templateDepends> on line $. refers to a template xml file '$templateFile' that has not been instanced.\n";
    }

  } else {
    die "Error: templateDepends has invalid format.   Must be all on one line with name= first and xmlFile= second.  Line $. file '$masterXmlFile'";
  }
  return @resolvedDepends;
}

sub usage {

  print "
Resolve a workflow master file.

Usage:  workflowResolveMaster master_xml_file lib_dir

Where:
  master_xml_file:  file with <templateInstance> elements
  lib_dir:          lib/ directory under which will be found the xml and rtc
                    files mentioned in the <templateInstance> elements

Output: the generated workflow xml file to STDOUT

";

  exit(1);
}
